* [Общая информация](#common_info)
* [Какие статусы HTTP возвращаются](#responce_status)
* [Доступные типы запросов для ресурсов](#request_url)
* [Статусы HTTP при ошибках](#responce_status_error)
* [Фильтрация, сортировка и пагинация списка](#filtering)
* [Авторизация](#auth_info)
* [Best practices for REST](#best_practices_for_rest)
* [HTTP-глаголы в REST](#http_verb)


<a name="common_info"></a>
## Общая информация

* Все данные доступны только в формате JSON. В качестве исключения могут быть png и jpeg.
* Базовый url — `https://DOMAIN.gstu.by/api/vN/`, где N >=1.
* <a name="date-format"></a> Даты форматируются в соответствии с [ISO 8601](http://en.wikipedia.org/wiki/ISO_8601): `YYYY-MM-DDThh:mm:ss` или `YYYY-MM-DD hh:mm:ss`.


<a name="responce_status"></a>
## Какие статусы HTTP возвращаются

Возможно 3 типа ответов API:

* Запрос прошел успешно ( 2xx ).
* На вход были переданы неправильные данные — клиентская ошибка ( 4xx ):
  * 400 Bad Request - клиент, составляя запрос, сделал что-то неправильно и он сам может ее исправить, правильно введя необходимую для запроса информацию.
  * 401 Unauthorized - неавторизованный пользователь.
  * 404 Not Found - данные не найдены или у пользователя нет прав на действие.
* Произошла ошибка при обработке данных — серверная ошибка ( 5xx ):
  * 500 Internal Server Error - неисправимая или неожиданная ошибка сервера.
  * 502 Bad Gateway - nginx получил недействительное ответное сообщение от сервера.
  * 504 Gateway Timeout - nginx не дождался ответа от сервера.

Ещё один тип ответов ( 3xx ) не используется в API, но эти ответы может возвращать nginx.
3хх говорит, что для успешного выполнения запроса нужно выполнить дополнительное действие.
Например, взять данные из кеша, если получено 304 Not Modified.


<a name="request_url"></a>
## Доступные типы запросов для ресурсов

Список доступных url: [https://cit.gstu.by/projects/esap-admin2/repository/revisions/master/entry/docs/Routes.md](https://cit.gstu.by/projects/esap-admin2/repository/revisions/master/entry/docs/Routes.md).

Для каждого из ресурсов может быть установлен определённый набор запросов. Доступны следующие типы запросов:

* `GET /resource/` – получает список всех объектов.
В ответе статус 200, а в теле ответа json-массив, обычно содержащий json-объекты.
* `POST /resource/` – создает новый объект, данные передаются в теле запроса.
В ответе статус 201, тело ответа пустое, в заголовке Location указывается url созданного ресурса.
* `GET /resource/{id}` – получает полную информацию об объекте с идентификатором {id}.
В ответе статус 200, в теле ответа json-объект.
* `PUT /resource/{id}` – изменяет объект с идентификатором {id}, все изменённые данные передаются в теле запроса.
Если какого-то поля нет в теле запроса, то считается, что ему присвоено null или undef.
В ответе статус 204, тело ответа пустое. Обновленный ресурс можно получить через `GET /resource/{id}`.
Другие возможные, но неиспользуемые варианты: в ответе статус или 201 (если ресурс создан), или 200 (ресурс обновлён, в ответе обновленный ресурс).
* `PATCH /resource/{id}` – изменяет объект с идентификатором {id}, изменённые данные передаются в теле запроса.
Сервер берёт те же данные, что и при `GET /resource/{id}`, записывает поверх них данные из запроса и сохраняет получившуюся запись.
В ответе статус 200, в теле ответа json-объект, точно такой же, как и при следующем `GET /resource/{id}`.
* `DELETE /resource/{id}` – удаляет объект с идентификатором {id}.
В ответе статус 204, тело ответа пустое, т.к. удаление прошло успешно и возвращать нечего.

* `GET /resource1/{id1}/resource2` – получает информацию об resource2, который связан с /resource1/{id}.
В ответе статус 200, в теле ответа или json-массив, или json-объект.
Тело ответа зависит от типа resource2,
т.е. похоже на `GET /resource2?resource1={id1}` и возвращается массив,
но если по бизнес-логике массив может содержать только один элемент, тогда возвращается этот элемент как json-объект.
* `PATCH /resource1/{id1}/resource2` – можно использовать, только если `GET /resource1/{id1}/resource2` возвращает объект.
Поведение и результат аналогичны `PATCH /resource/{id}`
* `PUT /resource1/{id1}/resource2` – можно использовать, только если `GET /resource1/{id1}/resource2` возвращает объект.
Поведение и результат аналогичны `PUT /resource/{id}`
* `PUT /resource/{id}/{value}` – объекту-скаляру с идентификатором {id} устанавливается значение {value}.
В ответе статус 204, тело ответа пустое.

Можно сравнить http-методы с sql-запросами:

* GET - `SELECT`,
* POST - `INSERT`,
* PUT - `INSERT ... ON DUPLICATE KEY UPDATE`,
* PATCH - `UPDATE`,
* DELETE - `DELETE`.

Примеры использования есть в тестах: [https://cit.gstu.by/projects/esap-admin2/repository/revisions/master/show/t](https://cit.gstu.by/projects/esap-admin2/repository/revisions/master/show/t).
Тесты - это по сути тоже клиент, только консольный.


<a name="responce_status_error"></a>
## Статусы HTTP при ошибках

При каждой ошибке, помимо кода ответа ( 4xx или 5xx ), в теле ответа выдаётся дополнительная информация, позволяющая разработчику понять причину ошибки.
Все ошибки выдаются в формате `{ "message": "..." }`.

Примеры, когда возвращается ошибка 400:

* Если клиент запросил '/api/v1/log', то отдавать миллион записей - это не очень хорошая идея. Возвращается ошибка `Очень большой ответ( $count > $max_count ). Используйте фильтр или пагинацию.`, где `$max_count` берётся из конфигурации.
* Неправильный url для пагинации, используется неположительное число в параметре page: `/api/v1/log?level=error&sort=timestamp:asc&page=w&page_size=3`.
* Попытка создать оператора с логином, который уже используется.

Т.е. при 4xx нужно исправить запрос: добавить параметр фильтрации, исправить параметр в url, изменить параметр "новый логин" в теле запроса, авторизоваться.

Примеры, когда возвращаются ошибки 5xx:

* "Не найден параметр конфигурации в БД".
* Запрос к БД вернул ошибку, т.е. или неправильный запрос, или БД упала.
* В случае непредвиденной ситуации

Т.е. при 5xx проблема возникла на сервере и для ее решения пользователь может отправить запрос к службе поддержки.
А служба поддержки может исправить сервер: запустить упавшую подсистему; добавить данные в БД; добавить дополнительную проверку, которая будет возвращать 4xx.


<a name="filtering"></a>
## Фильтрация, сортировка и пагинация списка

К запросу "GET /resource", подразумевающему выдачу списка объектов,
можно в параметрах указать сортировку, фильтрацию и пагинацию.

### Фильтрация списка

Параметры: `field1=X&field2=Y`.

Кроме прямого сравнения можно использовать шаблоны:

* '_' и '?' - один символ; '%' и '*' - произвольное количество символов.
* Символ ! на первой позиции преобразуется в отрицание.
* Символы >=, >, <=, < на первых позициях строки означают соответствующее сравнение.
* Строки "NULL" и "!NULL" означают "IS NULL" и "IS NOT NULL" соответственно. Писать можно в любом регистре, но в строке не может быть других символов, даже пробелов.

Пример: `/api/v1/log?level=!wa*&id=<=18962`.

### Сортировка списка

3 варианта параметров:

* `sort_field=xx&sort_order=desc`, `sort_field=xx&sort_order=asc`,
* `sort=-xx`, `sort=xx`,
* `sort=xx:desc`, `sort=xx:asc`.

Все варианты преобразовываются во внутренние поля "поле сортировки" и "порядок сортировки".
Если нет "поля сортировки", то сортировка не производится.
Если нет "порядка сортировки", то сортировка производится по возрастанию.

Множественная сортировка пока не поддерживается.

### Постраничный просмотр списка

По умолчанию постраничный просмотр списка не используется, а выдаются все данные.

2 варианта параметров:

* `page_offset=N&page_size=M`.
Смещение идёт с нуля.
Нельзя передавать только параметр `page_offset`, не передавая `page_size`.
* `page=N&page_size=M`.
Нумерация страниц идёт с единицы.
Нельзя передавать только `page`, не передавая `page_size`.

Следующие запросы возвращают одни и те же данные:

* `sort=f&page_size=3&page=1` и `sort=f&page_size=3&page_offset=0`;
* `sort=f&page_size=3&page=5` и `sort=f&page_size=3&page_offset=12`.

Если передать все 3 параметра ( `page`, `page_size` и `page_offset` ), то будут использованы только `page` и `page_size`.


<a name="auth_info"></a>
## Авторизация

Если пользователь не авторизован, то все запросы возвратят код 401.

Для авторизации нужно выполнить `POST /api/v1/auth` с параметрами `login` и `password`.

В случае успешной авторизации идентификатор пользователя заносится в сессию и в ответе возвращается статус 201, как и при любом создании ресурса.
В заголовке Location будет следующий url: `/api/v1/auth/логин`.

Запрос `GET /api/v1/auth/логин` вернёт `{ "login": "логин" }`.
Также логин авторизованного пользователя всегда можно узнать по запросу `GET /api/v1/auth`, который вернёт `[ { "login": "логин" } ]`.

Сессия - это signed cookies с названием mojolicious, в которой зашифрованы данные сессии.
В каждых следующих запросах сервер получает эту куку и расшифровывает её.

Права доступа текущего пользователя можно получить так: `GET /api/v1/auth/логин/privilege`.
Пример ответа: `{ "view_stud": 1, "view_operator": 1, "add_operator": 1 }`.

Пользователь может быть администратором.
Проверить это можно запросом `GET /api/v1/auth/логин/role`,
который вернёт или `{"admin": 0}`, или `{"admin": 1}`.

Администратор имеет все привилегии, вне зависимости от того, что возвращает `GET /api/v1/auth/логин/privilege`.

Для выхода из системы нужно выполнить `DELETE /api/v1/auth/логин`. В итоге идентификатор пользователя удалится из сессии.


<a name="best_practices_for_rest"></a>
## Best practices for REST

[http://www.restapitutorial.ru/](http://www.restapitutorial.ru/)

[http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api](http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api)

[http://microformats.org/wiki/rest/urls](http://microformats.org/wiki/rest/urls)

[https://github.com/abhishekisnot/Mojolicious-Plugin-REST/blob/master/RESTBestPractices.md](https://github.com/abhishekisnot/Mojolicious-Plugin-REST/blob/master/RESTBestPractices.md)

[https://habrahabr.ru/post/181988/](https://habrahabr.ru/post/181988/)

[https://habrahabr.ru/company/yandex/blog/265569/](https://habrahabr.ru/company/yandex/blog/265569/)

[https://toster.ru/q/23936](https://toster.ru/q/23936)

[https://ru.wikipedia.org/wiki/HTTP#Методы](https://ru.wikipedia.org/wiki/HTTP#.D0.9C.D0.B5.D1.82.D0.BE.D0.B4.D1.8B)


<a name="http_verb"></a>
## HTTP-глаголы в REST

GET используется для запроса содержимого указанного ресурса.
Методы GET, HEAD, OPTIONS и TRACE в стандарте определены как безопасные,
это означает, что они предназначены только для получения информации и не должны изменять состояние сервера.

POST не считается идемпотентным,
т.е. многократное повторение одних и тех же запросов POST может возвращать разные результаты.
Другими словами, POST может
создавать новые объекты при последовательных запросах на один урл,
и его нужно использовать для обращения к "производящим фабрикам".

PUT должен быть идемпотентной операцией,
т.е. несколько одинаковых последовательных запросов на один url (и с одинаковыми параметрами) не должны создавать новых объектов.

Помимо PUT идемпотентными также являются GET, DELETE, HEAD, TRACE и OPTIONS.

Различия между PATCH и PUT лишь в том,
что PUT предполагает заменить ресурс полностью,
а PATCH только частично обновить данные, т.е. применяется только к фрагменту ресурса.

PUT можно сравнить с `INSERT ... ON DUPLICATE KEY UPDATE`,
PATCH с `UPDATE`,
а POST — это чистый `INSERT`.
